#!/usr/bin/env python
#
# Clem
#
# This script is used inside pragma to boot up virtual cluster
#

import os, sys, string
from optparse import OptionParser, OptionGroup

import logging
import json


try:
    import pragma
except ImportError:
    #we need this to run from sources without installing fingerprint
    fullPath = os.path.dirname(os.path.realpath(__file__))
    parDir = os.path.abspath(os.path.join(fullPath, os.path.pardir))
    #we need to use our local patched python-ptrace and not the system one
    sys.path.insert(0, parDir)
    import pragma

#
# compatibility with python2.4
#
if "any" not in dir(__builtins__):
    from Pragma.utils import any



def main():
    #
    # set up the option parser
    #

    runHelp = "\nRun \"pragma_boot -h\" for more help."
    usage = "usage: %prog --vmname vmname --net_conf file [--num_compute N] [--basepath path]"
    parser = OptionParser(usage, version="0.1")


    # required options one of them must be selected
    group = OptionGroup(parser, "Required Options",
                    "You must select both a vmname and net_conf file")
    parser.add_option_group(group)
    group.add_option("--vmname", dest="vmname", default=None,
                    help="The name of the cluster which should be started")
    group.add_option("--net_conf", dest="net_conf", default="net_conf.conf",
                    help="A file containing all the public network configuration")

    #various option
    parser.add_option("--basepath", dest="basepath", default="/gfarm/vm-images",
                    help="The base path used to find all the cluster images")
    parser.add_option("--num_compute", dest="num_compute", default=0,
                    help="The nuber of computing node to start up")

    parser.add_option("-v", "--verbose", action="store_true", dest="verbose",
                    default=False,
                    help="Print all debugging information to stdout")
    (options, args) = parser.parse_args()


    #
    # switch based on user input
    #
    if not options.vmname:
        parser.error("you need to specify a vmname")
    if not os.path.isfile(options.net_conf):
        parser.error("you need to enter a valid net_conf file name")
    vc_db_filepath = options.basepath + "/vcdb.txt"
    if not os.path.isfile(vc_db_filepath) :
        parser.error("The file " + vc_db_filepath + " does not exist/\n"
            "Your basepath should point to a valid pragma virtaul cluster repository")


    # create logger
    logger = logging.getLogger('pragma_boot')
    logger.setLevel(logging.DEBUG)
    # create file handler which logs even debug messages
    #fh = logging.FileHandler('pragma_boot.log')
    #fh.setLevel(logging.DEBUG)
    #logger.addHandler(fh)
    # create console handler and set level to debug
    ch = logging.StreamHandler()
    if options.verbose :
        ch.setLevel(logging.DEBUG)
    else:
        ch.setLevel(logging.ERROR)
    logger.addHandler(ch)


    # dirty and nasty but fast!!
    # it will define the follwing variable
    # public_ip
    # netmask
    # gw
    # dns
    # fqdn
    execfile(options.net_conf, {}, globals())

    vc_in_filepath = None
    with open(vc_db_filepath, 'r') as vc_db:
        for line in vc_db:
            (vmname, temp_path) = line.split(',')
            if options.vmname == vmname:
                vc_in_filepath = options.basepath + "/" + temp_path.strip()
                break
        if not vc_in_filepath:
            logger.error("vmname " + options.vmname + " does not exist in VC database.\n"
                "Check the VC database file " + vc_db_filepath)
            sys.exit(-1)
    # parse the vc-in file
    # vc_in_dom = xml.dom.minidom.parse(vc_in_filepath)[0]
    with open(vc_in_filepath) as vc_in:
        vc = json.loads(vc_in.read())["vc"]
    if vc["arch"] != "x86_64":
        logger.error("Error unsupported architecture in " + vc_in_filepath)
        sys.exit(-1)
    for device in vc["frontend"]["devices"]:
        if "disk" in device:
            src_file = device["disk"]["source_file"]
            format = device["disk"]["format"]












if __name__ == "__main__":
    main()

