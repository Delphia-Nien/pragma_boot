#!/usr/bin/env python
#
# Clem
#
# This script is used inside pragma to boot up virtual cluster
#
# requires python-elementtree on RHEL 5.x

import os, sys, string
from optparse import OptionParser, OptionGroup

import logging
import gzip
import time
import xml.etree.ElementTree

#we need this to run from sources without installing
fullPath = os.path.dirname(os.path.realpath(__file__))
script_base_dir = os.path.abspath(os.path.join(fullPath, os.path.pardir))

try:
    import pragma
except ImportError:
    #we need to use our local patched python-ptrace and not the system one
    sys.path.insert(0, script_base_dir)
    import pragma
import pragma.utils

#
# compatibility with python2.4
#
if "any" not in dir(__builtins__):
    from Pragma.utils import any



def main():

    #
    # set up the option parser
    #
    runHelp = "\nRun \"pragma_boot -h\" for more help."
    usage = "usage: %prog --vcname vcname --net_conf file [--num_compute N] [--basepath path]"
    parser = OptionParser(usage, version="0.1")


    # required options one of them must be selected
    group = OptionGroup(parser, "Required Options",
                    "You must select both a vcname and net_conf file")
    parser.add_option_group(group)
    group.add_option("--vcname", dest="vcname", default=None,
                    help="The name of the cluster which should be started")
    group.add_option("--net_conf", dest="net_conf", default="net_conf.conf",
                    help="A file containing all the public network configuration")

    #various option
    parser.add_option("--basepath", dest="basepath", default="/gfarm/vm-images",
                    help="The base path used to find all the cluster images")
    parser.add_option("--num_compute", dest="num_compute", default=0,
                    help="The nuber of computing node to start up")

    parser.add_option("-v", "--verbose", action="store_true", dest="verbose",
                    default=False,
                    help="Print all debugging information to stdout")
    (options, args) = parser.parse_args()


    #
    # switch based on user input
    #
    if not options.vcname:
        parser.error("you need to specify a vcname")
    if not os.path.isfile(options.net_conf):
        parser.error("you need to enter a valid net_conf file name")
    vc_db_filepath = options.basepath + "/vcdb.txt"
    if not os.path.isfile(vc_db_filepath) :
        parser.error("The file " + vc_db_filepath + " does not exist/\n"
            "Your basepath should point to a valid pragma virtaul cluster repository")


    # create logger
    global logger
    logger = logging.getLogger('pragma_boot')
    logger.setLevel(logging.DEBUG)
    # create file handler which logs even debug messages
    #fh = logging.FileHandler('pragma_boot.log')
    #fh.setLevel(logging.DEBUG)
    #logger.addHandler(fh)
    # create console handler and set level to debug
    ch = logging.StreamHandler()
    if options.verbose :
        ch.setLevel(logging.DEBUG)
    else:
        ch.setLevel(logging.ERROR)
    logger.addHandler(ch)

    # dirty and nasty but fast!!
    # it will define the follwing variable
    # public_ip
    # netmask
    # gw
    # dns
    # fqdn
    execfile(options.net_conf, {}, globals())
    # this imports the following values
    # site_ve_driver
    # temp_directory
    execfile(script_base_dir + "/site_conf.conf", {}, globals())
    ve_driver_base_path = script_base_dir + "/drivers/" + site_ve_driver

    vc_in_filepath = None
    with open(vc_db_filepath, 'r') as vc_db:
        for line in vc_db:
            (vcname, temp_path) = line.split(',')
            if options.vcname == vcname:
                vc_in_filepath = options.basepath + "/" + temp_path.strip()
                break
        if not vc_in_filepath:
            logger.error("vcname " + options.vcname + " does not exist in VC database.\n"
                "Check the VC database file " + vc_db_filepath)
            sys.exit(-1)
    # parse the vc-in file
    # rant: to get tree values out of a configuration file you need 
    # 15 lines of code! XML such a great invention
    vc_in_xmlroot = xml.etree.ElementTree.parse(vc_in_filepath).getroot()

    # get the arch
    if vc_in_xmlroot.findall('./virtualization')[0].attrib['arch'] != "x86_64":
        logger.error("Error unsupported architecture in " + vc_in_filepath)
        sys.exit(-1)
    # get the driver name
    client_driver_name = vc_in_xmlroot.findall('./driver')[0].text
    # 
    disk=vc_in_xmlroot.findall('./frontend/domain/devices/disk/source')[0]
    src_file = disk.attrib['file']
    client_driver_base_path = script_base_dir + "/drivers/" + client_driver_name

    #
    # copy FE disk image over to temp floder and uncompress it
    #
    fe_disk_path = os.path.dirname(vc_in_filepath) + "/" + src_file
    if not os.path.isfile(fe_disk_path):
        logger.error("Error can not open FE disk image " + fe_disk_path)
        sys.exit(-1)
    if fe_disk_path.endswith(".gz"):
        temp_disk_path = temp_directory + '/' + os.path.basename(fe_disk_path)[:-3]
        deflate_file(fe_disk_path, temp_disk_path)
    else:
        temp_disk_path = temp_directory + '/' + os.path.basename(fe_disk_path)
        shutil.copy(fe_disk_path, temp_disk_path)

    #
    # start fixing the image
    #

    # prefix_driver
    cmdline = client_driver_base_path + "/pre_fix_driver " + temp_disk_path
    runCommand(cmdline)

    # creating the domain.xml for libvirt
    xml_fe_path = temp_directory + '/vc-in.xml'
    fe_domain = vc_in_xmlroot.findall('./frontend/domain')[0]
    fe_disk_source = fe_domain.findall('./devices/disk/source')[0]
    fe_disk_source.attrib['file'] = temp_disk_path
    xml.etree.ElementTree.ElementTree( fe_domain ).write(xml_fe_path)
    # figuring out the interface name list
    interface_list = ""
    for interface in fe_domain.findall('./devices/interface/source'):
        if 'dev' in interface.attrib:
            interface_list += interface.attrib['dev']
        if 'bridge' in interface.attrib:
            interface_list += interface.attrib['bridge']
        interface_list += ","

    # fix_driver
    cmdline = ve_driver_base_path + "/fix_driver " + xml_fe_path + " " + interface_list
    # TODO add interfaces
    runCommand(cmdline)

    # postfix_driver
    cmdline = client_driver_base_path + "/post_fix_driver " + temp_disk_path
    runCommand(cmdline)
    



def runCommand(cmdline):
    logger.debug("Executing: " + cmdline)
    (stdout, ret) = pragma.utils.getOutputAsList(cmdline)
    if ret != 0 :
        logger.error("Error while running: " + cmdline)
        logger.error('\n'.join(stdout))
        sys.exit(-1)
    logger.debug("Command executed: " + cmdline)
    logger.debug("Output: " + '\n'.join(stdout))


def deflate_file(srcpath, destpath):
    """it gunzip a file """
    logger.debug("Uncompressing file " + srcpath + " in " + destpath)
    return
    buf_size=16384
    input = gzip.open(srcpath)
    output = open(destpath, 'w')
    temp_timer = time.time()
    counter = 0
    while True:
        buffer =  input.read(buf_size)
        if len(buffer) == 0:
            break
        output.write( buffer )
        if counter == 1000:
            logger.debug("Decoded " + str(buf_size * 1000) + " in " + str(time.time() - temp_timer))
            temp_timer = time.time()
            counter = 0
        counter += 1
    input.close()
    output.close()
    logger.debug("File " + destpath + " uncompressed.")
    
    
    













if __name__ == "__main__":
    main()

