#!/usr/bin/env python
#
# Clem
#
# This script is used inside pragma to boot up virtual cluster
#
# requires python-elementtree on RHEL 5.x

import os, sys, string
from optparse import OptionParser, OptionGroup

import logging
import gzip
import time
import xml.etree.ElementTree

#we need this to run from sources without installing
fullPath = os.path.dirname(os.path.realpath(__file__))
script_base_dir = os.path.abspath(os.path.join(fullPath, os.path.pardir))

try:
    import pragma
except ImportError:
    #we need to use our local patched python-ptrace and not the system one
    sys.path.insert(0, script_base_dir)
    import pragma
import pragma.utils
import pragma.repository.utils

#
# compatibility with python2.4
#
if "any" not in dir(__builtins__):
    from Pragma.utils import any


mockup_vc_out_xml='''
<vc>
<frontend>
    <public fqdn="somehost.ucsd.edu" ip="127.111.111.222" netmask="255.255.255.0" gw="127.111.111.1" mac="7a:77:6e:40:00:16" />
    <private ip="10.1.1.1" netmask="255.255.0.0" mac="7a:77:6e:40:00:15"/>
  </frontend>
  <compute count="2">
    <node name='hosted-vm-0-1-0' mac='7a:77:6e:40:00:18' ip='10.1.1.254' cpus='2'/>
    <node name='hosted-vm-0-0-0' mac='7a:77:6e:40:00:17' ip='10.1.1.253' cpus='2'/>
  </compute>
  <network>
    <dns ip="8.8.8.8" search="local" domain=""/>
  </network>
</vc>
'''


class drivers_manager:
    """manages the paths to the various drivers"""

    def set_client_base_path(self, path):
        self.client_driver_base_path = path

    def set_ve_base_path(self, path):
        self.ve_driver_base_path = path

    def allocate(self):
        path = self.ve_driver_base_path + '/allocate'
        return self._get_path(path)

    def pre_fix_driver(self):
        path = self.client_driver_base_path + '/pre_fix_driver'
        return self._get_path(path)

    def fix_images(self):
        path = self.ve_driver_base_path + '/fix_images'
        return self._get_path(path)

    def post_fix_driver(self):
        path = self.client_driver_base_path + '/post_fix_driver'
        return self._get_path(path)

    def pre_boot(self):
        path = self.client_driver_base_path + '/pre_boot'
        return self._get_path(path)

    def boot(self):
        path = self.ve_driver_base_path + '/boot'
        return self._get_path(path)

    def _get_path(self, path):
        #TODO make execution of driver optional
        if os.path.isfile(path):
            return path
        else:
            return None


def main():

    # Load configuration
    # this imports the following values
    # site_ve_driver
    # temp_directory
    # repository_class
    # repository_dir
    # repository_settings
    execfile(script_base_dir + "/site_conf.conf", {}, globals())

    #
    # set up the option parser
    #
    runHelp = "\nRun \"pragma_boot -h\" for more help."
    usage = "usage: %prog [-v][-d][--basepath path] --list [options] | --vcname vcname [options]"
    parser = OptionParser(usage, version="0.2")

    # global options
    parser.add_option("--basepath", dest="basepath", default=repository_dir,
                    help="The base path used to find all the cluster images "
                    "(default is /gfarm/vm-images)")
    parser.add_option("-v", "--verbose", action="store_true", dest="verbose",
                    default=False,
                    help="Print all debugging information to stdout")
    parser.add_option("-d", "--debug", action="store_true", dest='debug',
                    default=False, help="Print only the command that will be "
                    "executed do not execute them")

    # Options for --list command
    parser.add_option("--list", dest="list", action="store_true",
                    help="list available virtual machines")
    list_group = OptionGroup(parser, "List Options",
                    "Options for --list command")
    parser.add_option_group(list_group)

    # Options for --vcname command
    parser.add_option("--vcname", dest="vcname", default=None,
                    help="The name of the cluster which should be started")
    create_group = OptionGroup(parser, "Create Options",
                    "Options for --vcname command")
    parser.add_option_group(create_group)
    create_group.add_option("--key", dest="key", default="/root/.ssh/id_rsa.pub",
                    help="The ssh key that will be authorized on the frontend "
                    "of the cluster (default is /root/.ssh/id_rsa.pub)")
    create_group.add_option("--num_cpus", dest="num_cpus", default=0, type="int",
                    help="The nuber of cpus requested to start up (default is 0 "
                    " only frontend will be started")
    create_group.add_option("--enable-ipop-client", dest="ipop_clientinfo_file", default="",
                    help="Start up the IPOP-enabled virtual cluster as an IPOP client (to "
                    "another virtual cluster) using the provided IPOP server info file" )
    create_group.add_option("--enable-ipop-server", dest="ipop_serverinfo_url", default="",
                    help="Start up the IPOP-enabled virtual cluster with the frontend serving"
                    " as an IPOP server; once initialization is complete, store the IPOP "
                    "server info into the provided URL.  If begins with file://, will "
                    "be stored locally, otherwise will be a REST call if begins with http://" ) 
    (options, args) = parser.parse_args()

    if options.ipop_clientinfo_file != "" and options.ipop_serverinfo_url != "":
      parser.error( "Cannot specify both --enable-ipop-server and --enable-ipop-client" )

    #
    # switch based on user input
    #
    if not options.vcname and not options.list:
        parser.error("you need to specify a vcname")
    vc_db_filepath = options.basepath + "/vcdb.txt"

    # Download vcdb
    klass = pragma.repository.utils.import_class(repository_class)
    repository_settings["cache_dir"] = repository_dir
    repository = klass(repository_settings)
    repository.download_vcdb_file()

    if not os.path.isfile(vc_db_filepath):
        parser.error("The file " + vc_db_filepath + " does not exist/\n"
            "Your basepath should point to a valid PRAGMA virtual cluster repository")

    #
    # create logger
    #
    global logger
    logger = logging.getLogger('pragma_boot')
    logger.setLevel(logging.DEBUG)
    # create file handler which logs even debug messages
    fh = logging.FileHandler('pragma_boot.log')
    fh.setLevel(logging.DEBUG)
    formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
    fh.setFormatter(formatter)
    logger.addHandler(fh)
    # create console handler and set level to debug
    ch = logging.StreamHandler()
    if options.verbose:
        ch.setLevel(logging.DEBUG)
    else:
        ch.setLevel(logging.ERROR)
    logger.addHandler(ch)

    #
    # list cluster and exit
    #
    if options.list:
        print "Available virtual cluters:"
        with open(vc_db_filepath, 'r') as vc_db:
            for line in vc_db:
                (vcname, temp_path) = line.split(',')
                # Remove file existence checking as we still haven't download it
                # if os.path.isfile(options.basepath + "/" + temp_path.strip()):
	        print vcname
        sys.exit(0)

    dr_manager = drivers_manager()
    dr_manager.set_ve_base_path(script_base_dir + "/drivers/" + site_ve_driver)

    #
    # look up requested image in the vcdb.txt database
    #
    vc_in_filepath = None
    with open(vc_db_filepath, 'r') as vc_db:
        for line in vc_db:
            (vcname, temp_path) = line.split(',')
            if options.vcname == vcname:
                vc_in_filepath = options.basepath + "/" + temp_path.strip()
                break
        if not vc_in_filepath:
            logger.error("vcname " + options.vcname + " does not exist in VC database.\n"
                "Check the VC database file " + vc_db_filepath)
            sys.exit(1)

    # Download vc to cache
    repository.download_and_process_vc(options.vcname)

    # parse the vc-in file
    vc_in_xmlroot = xml.etree.ElementTree.parse(vc_in_filepath).getroot()

    # get the arch
    if vc_in_xmlroot.findall('./virtualization')[0].attrib['arch'] != "x86_64":
        logger.error("Error unsupported architecture in " + vc_in_filepath)
        sys.exit(1)
    # get the client driver name from the xml file
    client_driver_name = vc_in_xmlroot.findall('./driver')[0].text
    dr_manager.set_client_base_path(script_base_dir + "/drivers/" + client_driver_name)

    #
    # now we first call fix_image
    #
    # TODO properly set the node_types argument
    (fe_temp_disk_path, comp_temp_disk_path) = prepareImage(vc_in_filepath, temp_directory, "frontend,compute", dr_manager, options.debug)
    
    #
    # and then we call allocate and create vc-out.xml
    #
    vc_out_filepath = temp_directory + "/vc-out.xml"
    cmdline = [dr_manager.allocate(), str(options.num_cpus), vc_in_filepath,
            vc_out_filepath, temp_directory, options.key]
    if not options.debug:
        (stdout, ret) = pragma.utils.getOutputAsList(cmdline)
    else:
        # write fake vc_out_xml
        fd = open(vc_out_filepath, 'w')
        fd.write(mockup_vc_out_xml)
        fd.close()
        (stdout, ret) = ("", 0)
    stdout = '\n'.join(stdout)
    if ret != 0:
        logger.error("Not enough resources on the cluster to run %s cpus" %
            options.num_cpus)
        logger.error(stdout)
        sys.exit(1)
    logger.info("Command: " + ' '.join(cmdline))
    logger.info("Output: " + stdout)
    vc_out_xmlroot = xml.etree.ElementTree.parse(vc_out_filepath)
    pubblic_node = vc_out_xmlroot.findall('./frontend/public')[0]
    public_ip = pubblic_node.attrib["ip"]
    fqdn = pubblic_node.attrib["fqdn"]
    netmask = pubblic_node.attrib["netmask"]
    gw = pubblic_node.attrib["gw"]
    dns_node = vc_out_xmlroot.findall('./network/dns')[0]
    dns_servers = dns_node.attrib["ip"]
    node_names = []
    for node_xml in vc_out_xmlroot.findall('./compute/node'):
        node_names.append(node_xml.attrib["name"])
    # search="local" domain=""
    logger.info("Resource allocated: fqdn=" + fqdn + " - ip=" + public_ip +
            " - netmask=" + netmask + " - gw=" + gw)

    #
    # deploy frontend
    #

    deployImage(fe_temp_disk_path, fqdn, temp_directory, vc_out_filepath, dr_manager, options.debug, options.ipop_serverinfo_url, "0" )

    ipop_serverinfo_url = options.ipop_serverinfo_url if options.ipop_serverinfo_url != "" else options.ipop_clientinfo_file
    if options.num_cpus > 0 :
        #
        # deploy nodes
        #
        for i in node_names:
            deployImage(comp_temp_disk_path, i, temp_directory, vc_out_filepath, dr_manager, options.debug, ipop_serverinfo_url, "1")

def prepareImage(vc_in_filepath, temp_direcotry, node_type, dr_manager, debug):
    """ prepare the virtual images to be run on the current platform """
    # fix_driver
    cmdline = [dr_manager.fix_images(), vc_in_filepath, temp_directory, node_type]
    stdout=runCommand(cmdline, debug)
    filepaths=""
    while( filepaths == "" ):
      filepaths=stdout.pop()
    print filepaths
    fe_temp_disk_path = filepaths.split(" ")[0]
    comp_temp_disk_path = filepaths.split(" ")[1]
    return (fe_temp_disk_path, comp_temp_disk_path)

def deployImage(temp_disk_path, fqdn, temp_directory, vc_out_filepath, dr_manager, debug, ipop_serverinfo_url, ipop_client ):
    """ it runs the boot script on a machine once """
    cmdline = [dr_manager.boot(), temp_disk_path, fqdn, temp_directory, vc_out_filepath, ipop_serverinfo_url, ipop_client ]
    runCommand(cmdline, debug)


def runCommand(cmdline, debug):
    logger.debug("Executing: " + str(cmdline))
    if debug:
        logger.debug("Executed")
        return
    (stdout, ret) = pragma.utils.getOutputAsList(cmdline)
    if ret != 0:
        logger.error("Error while running: " + str(cmdline))
        logger.error('\n'.join(stdout))
        sys.exit(1)
    logger.info("Command executed: " + str(cmdline))
    logger.debug("Output: " + '\n'.join(stdout))
    return stdout


#TODO not used delete me
def deflate_file(srcpath, destpath, debug):
    """it gunzip a file """
    logger.info("Uncompressing file " + srcpath + " in " + destpath)
    if debug:
        logger.debug("File uncompressed")
        return
    buf_size = 16384
    input = gzip.open(srcpath)
    output = open(destpath, 'w')
    temp_timer = time.time()
    counter = 0
    while True:
        buffer = input.read(buf_size)
        if len(buffer) == 0:
            break
        output.write(buffer)
        if counter == 1000:
            logger.debug("Decoded " + str(buf_size * 1000) + " in " +
                str(time.time() - temp_timer))
            temp_timer = time.time()
            counter = 0
        counter += 1
    input.close()
    output.close()
    logger.info("File " + destpath + " uncompressed.")


if __name__ == "__main__":
    main()
