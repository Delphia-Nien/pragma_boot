#!/usr/bin/env python
#
# Clem
#
# This script is used inside pragma to boot up virtual cluster
#
# requires python-elementtree on RHEL 5.x

import os, sys, string
from optparse import OptionParser, OptionGroup

import logging
import gzip
import time
import xml.etree.ElementTree

#we need this to run from sources without installing
fullPath = os.path.dirname(os.path.realpath(__file__))
script_base_dir = os.path.abspath(os.path.join(fullPath, os.path.pardir))

try:
    import pragma
except ImportError:
    #we need to use our local patched python-ptrace and not the system one
    sys.path.insert(0, script_base_dir)
    import pragma
import pragma.utils

#
# compatibility with python2.4
#
if "any" not in dir(__builtins__):
    from Pragma.utils import any



def main():

    #
    # set up the option parser
    #
    runHelp = "\nRun \"pragma_boot -h\" for more help."
    usage = "usage: %prog --vcname vcname [--num_compute N] [--basepath path]"
    parser = OptionParser(usage, version="0.1")


    # required options one of them must be selected
    group = OptionGroup(parser, "Required Options",
                    "You must select both a vcname and net_conf file")
    parser.add_option_group(group)
    group.add_option("--vcname", dest="vcname", default=None,
                    help="The name of the cluster which should be started")

    #various option
    parser.add_option("--basepath", dest="basepath", default="/gfarm/vm-images",
                    help="The base path used to find all the cluster images")
    parser.add_option("--num_cpus", dest="num_cpus", default=0,
                    help="The nuber of cpus requested to start up")

    parser.add_option("-v", "--verbose", action="store_true", dest="verbose",
                    default=False,
                    help="Print all debugging information to stdout")
    (options, args) = parser.parse_args()


    #
    # switch based on user input
    #
    if not options.vcname:
        parser.error("you need to specify a vcname")
    vc_db_filepath = options.basepath + "/vcdb.txt"
    if not os.path.isfile(vc_db_filepath) :
        parser.error("The file " + vc_db_filepath + " does not exist/\n"
            "Your basepath should point to a valid pragma virtaul cluster repository")

    # create logger
    global logger
    logger = logging.getLogger('pragma_boot')
    logger.setLevel(logging.DEBUG)
    # create file handler which logs even debug messages
    #fh = logging.FileHandler('pragma_boot.log')
    #fh.setLevel(logging.DEBUG)
    #logger.addHandler(fh)
    # create console handler and set level to debug
    ch = logging.StreamHandler()
    if options.verbose :
        ch.setLevel(logging.DEBUG)
    else:
        ch.setLevel(logging.ERROR)
    logger.addHandler(ch)

    # this imports the following values
    # site_ve_driver
    # temp_directory
    execfile(script_base_dir + "/site_conf.conf", {}, globals())
    ve_driver_base_path = script_base_dir + "/drivers/" + site_ve_driver

    # look in the vcdb.txt database for the machine name
    vc_in_filepath = None
    with open(vc_db_filepath, 'r') as vc_db:
        for line in vc_db:
            (vcname, temp_path) = line.split(',')
            if options.vcname == vcname:
                vc_in_filepath = options.basepath + "/" + temp_path.strip()
                break
        if not vc_in_filepath:
            logger.error("vcname " + options.vcname + " does not exist in VC database.\n"
                "Check the VC database file " + vc_db_filepath)
            sys.exit(-1)
    # parse the vc-in file
    vc_in_xmlroot = xml.etree.ElementTree.parse(vc_in_filepath).getroot()

    # get the arch
    if vc_in_xmlroot.findall('./virtualization')[0].attrib['arch'] != "x86_64":
        logger.error("Error unsupported architecture in " + vc_in_filepath)
        sys.exit(-1)
    # get the client driver name from the xml file
    client_driver_name = vc_in_xmlroot.findall('./driver')[0].text
    client_driver_base_path = script_base_dir + "/drivers/" + client_driver_name
    # get the disk path
    disk=vc_in_xmlroot.findall('./frontend/domain/devices/disk/source')[0]
    src_file = disk.attrib['file']

    #
    # First let's check if we have enough resources to start this cluster 
    # and let's create vc-out.xml
    #
    vc_out_filepath = temp_directory + "/vc-out.xml"
    cmdline = [ve_driver_base_path + "/allocate", str(options.num_cpus), vc_out_filepath]
    (stdout, ret) = pragma.utils.getOutputAsList(cmdline)
    stdout = '\n'.join(stdout)
    if ret != 0 :
        logger.error("Now enough resources on the cluster to run %s cpus" % options.num_cpus)
        logger.error(stdout)
        sys.exit(-1)
    logger.info("Command: " + ' '.join(cmdline))
    logger.info("Output: " + stdout)
    vc_out_xmlroot = xml.etree.ElementTree.parse(vc_out_filepath)
    pubblic_node = vc_out_xmlroot.findall('./frontend/public')[0]
    public_ip = pubblic_node.attrib["ip"]
    fqdn = pubblic_node.attrib["fqdn"]
    netmask = pubblic_node.attrib["netmask"]
    gw = pubblic_node.attrib["gw"]
    dns_node = vc_out_xmlroot.findall('./network/dns')[0]
    dns_servers = dns_node.attrib["ip"]
    # search="local" domain=""
    logger.info("Resource allocated: fqdn=" + fqdn + " - ip=" + public_ip + " - netmask=" + netmask + " - gw=" + gw)

    #
    # copy FE disk image over to temp floder and uncompress it
    #
    fe_disk_path = os.path.dirname(vc_in_filepath) + "/" + src_file
    if not os.path.isfile(fe_disk_path):
        logger.error("Error can not open FE disk image " + fe_disk_path)
        sys.exit(-1)
    if fe_disk_path.endswith(".gz"):
        temp_disk_path = temp_directory + '/' + os.path.basename(fe_disk_path)[:-3]
        deflate_file(fe_disk_path, temp_disk_path)
    else:
        temp_disk_path = temp_directory + '/' + os.path.basename(fe_disk_path)
        shutil.copy(fe_disk_path, temp_disk_path)

    #
    # start fixing the image
    #

    # prefix_driver
    cmdline = client_driver_base_path + "/pre_fix_driver " + temp_disk_path 
    runCommand(cmdline)

    # extracting domain.xml for libvirt from vc-in.xml
    xml_fe_path = temp_directory + '/vc-in.xml'
    fe_domain = vc_in_xmlroot.findall('./frontend/domain')[0]
    fe_disk_source = fe_domain.findall('./devices/disk/source')[0]
    fe_disk_source.attrib['file'] = temp_disk_path
    xml.etree.ElementTree.ElementTree( fe_domain ).write(xml_fe_path)
    # figuring out the interface name list
    interface_list = ""
    for interface in fe_domain.findall('./devices/interface/source'):
        if 'dev' in interface.attrib:
            interface_list += interface.attrib['dev']
        if 'bridge' in interface.attrib:
            interface_list += interface.attrib['bridge']
        interface_list += ","

    # fix_driver
    cmdline = [ve_driver_base_path + "/fix_driver", xml_fe_path, interface_list,
                temp_directory]
    runCommand(cmdline)

    # postfix_driver
    cmdline = [client_driver_base_path + "/post_fix_driver", temp_disk_path]
    runCommand(cmdline)

    # dmreread the xml_fe_path to see changes in the VM

    # pre_boot takes care of fixing the network on the image before booting it
    cmdline = [client_driver_base_path + "/pre_boot", temp_disk_path, xml_fe_path,
                vc_out_filepath, fqdn]
    runCommand(cmdline)

    cmdline = [ve_driver_base_path + "/boot", temp_disk_path, xml_fe_path, fqdn]
    runCommand(cmdline)

    # for the compute
    # <!-- change eth0 to be dhcp and mac address neutral -->
    # <file name="/etc/sysconfig/network-scripts/ifcfg-eth0">
    # DEVICE=eth0
    # BOOTPROTO=dhcp
    # ONBOOT=yes
    # </file>
    #
    # <!-- change network file to not have hostname of gateway -->
    # <file name="/etc/sysconfig/network">
    # NETWORKING=yes
    # </file>
    #



def runCommand(cmdline):
    logger.debug("Executing: " + cmdline)
    (stdout, ret) = pragma.utils.getOutputAsList(cmdline)
    if ret != 0 :
        logger.error("Error while running: " + cmdline)
        logger.error('\n'.join(stdout))
        sys.exit(-1)
    logger.info("Command executed: " + cmdline)
    logger.debug("Output: " + '\n'.join(stdout))


def deflate_file(srcpath, destpath):
    """it gunzip a file """
    logger.info("Uncompressing file " + srcpath + " in " + destpath)
    buf_size=16384
    input = gzip.open(srcpath)
    output = open(destpath, 'w')
    temp_timer = time.time()
    counter = 0
    while True:
        buffer =  input.read(buf_size)
        if len(buffer) == 0:
            break
        output.write( buffer )
        if counter == 1000:
            logger.debug("Decoded " + str(buf_size * 1000) + " in " + str(time.time() - temp_timer))
            temp_timer = time.time()
            counter = 0
        counter += 1
    input.close()
    output.close()
    logger.info("File " + destpath + " uncompressed.")
    
    


if __name__ == "__main__":
    main()

